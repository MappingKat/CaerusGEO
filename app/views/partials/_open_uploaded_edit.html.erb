<%= render :partial => "partials/survey_finished_questions", :locals => {:open => true} %>
<% map_form = @report.survey.actual_questions.first.form %>
<% content_for :current_page_class do %>report_edit_upload report_edit<% end %>
<% content_for :current_body_id do %>uploaded_edit_section<% end %>

<script id="loc_template" type="text/x-underscore-tmpl">
    <@ _.each(points,function(point) { @>
      <div class="input-prepend" style="margin-bottom:18px;">
          <span class="add-on">lat</span>
          <input class="input-small" type="text" value="<@= point.lat @>">
          <span class="add-on">lng</span>
          <input class="input-small" type="text" value="<@= point.lng @>">
      </div>
    <@ }) @>
</script>

<div class="row">
  	<div class="span4">
      <label class="question_label">Choose Entry ID</label>
      <select style="width:200px;" id="entry_selector">
        <option></option>
        <% @report.spresults.order(:id).each do |spresult| %>
          <option value="<%= spresult.id %>"><%= spresult.status ? '<i class="icon-ok"></i>' : '<i class="icon-remove"></i> ' %> <%= spresult.uid %></option>
        <% end %>
      </select>

      <label class="question_label" style="margin-top:16px;">Location</label>

      <p id="instructions">NO LOCATION</p>

      <p id="pending"></p>

      <p id="ready"></p>

      <div id="location_data"></div>

      <div id="questions_div">
        <ul id="questions"></ul>
      </div>
	</div>

  <div class="span8">
     <div id="map"></div>
  </div>
</div>


<script>

  <% if @report.survey.types_used.include?('datetime') %>
  window.tz_abbr = "<%= ActiveSupport::TimeZone.zones_map[@survey.time_zone].now.strftime('%Z') %>";
  <% end %>

  var Spresult = Backbone.Model.extend({
      urlRoot:"<%= url_for survey_report_spresults_path(@report.survey,@report) %>",
      launchOn: function() {
        this.trigger('entryLoaded', this);
      }
  })

  var SpresultCollection = Backbone.Collection.extend({
      model: Spresult
  });

  var Spresults = new SpresultCollection();
  Spresults.url = '<%= url_for survey_report_spresults_path(@report.survey,@report) %>';

  var area = <%= raw @report.survey.area.bounds.to_json %>;
  var grids = <%= raw @report.survey.area.grids.includes(:ne,:sw).to_json %>;
  var full_count = <%= @report.spresults.count %>;
  var map_form = "<%= map_form %>";

  var Question_mod = Backbone.Model.extend({});
  var QuestionCollection_mod = Backbone.Collection.extend({
    model: Question_mod
  });

  var questions = new QuestionCollection_mod(<%= raw @report.survey.actual_questions.to_json %>);

  var UploadedEditSection = baseEditView.extend({

    el: "#uploaded_edit_section",

    events: {
      'click #save_finish_button' : 'leaveEdit',
      'change select' : 'selectorChange',
      'click .pointsetter-commit' : 'saveCurrent',
      'keydown #location_data' : 'geoKey'
    },

    initialize: function() {
      this.drawInProgress = false;
      this.map = this.initMap(null,true);

      this.updateProgressBar();

      //Event Bindings
      this.listenTo(this.collection, "loadedFinishedEntry", this.loadedFinished);
      this.listenTo(this.collection, "loadedUnfinishedEntry", this.loadedUnfinished);
      this.listenTo(this.collection,"entryLoaded", this.entryLoad);
      
      this.listenTo(this.options.questions, "change:answer", this.handleAnswers)

      //Prep Instructional cues
      var thismap = form_to_nameset[map_form];
      this.$el.find("#pending").text(thismap.pending_text);
      this.$el.find("#ready").text('Finish with the '+ thismap.entity_name + " button on the map.");

      //Prep Entry selector
      var select2_options = {placeholder: "Select a response"}
      var selectorMain = this.$el.find('select');
      if (this.$el.find("option[value!='']").length < 15) {
        select2_options['dropdownCssClass'] = "no-search";
      }
      selectorMain.select2(select2_options);

      //Prep questions
      this.handleQuestionSetup(this.options.questions,this.options.method,area,grids) // init questions
      this.$el.find('input.answer').attr('disabled','disabled');

      this.map_question = this.options.questions.findWhere({label: "Geo Response"});

      //Prep drawing tool
      this.updateDrawTool(thismap);

      // Manual setting of first entry.
      var firstval = parseInt(selectorMain.find("option[value!='']").first().val()); //Get the first entry. 
      selectorMain.select2("val", firstval); //Set the select2box to the first one.
      this.loadResult(firstval);  //and load it.
    },

    geoKey: function(e) {
      return false;
    },

    handleAnswers: function(model) {
      var self = this;
      var form = model.get('form');
      var answer = model.get('answer');
      var q_id = model.get('id');
      if (answer) {
        //if there an answer actually present.On first load, there isnt.
        if ((form == 'fillin' && answer['text'] != null) || 
            (form != 'fillin' && !_.isEmpty(answer['points'])) || 
            (form == 'number' && answer['number'] != null) || 
            (form == 'date' && answer['stamp'] != null) || 
            (form == 'datetime' && answer['stamp'] != null)
           )
          //is the answer actually filled in.

          if (form == 'fillin') {
            self.$el.find("#"+q_id).find('input').val(answer['text']);
          }
          else if (form == 'number') {
            self.$el.find("#"+q_id).find('input').val(answer['number']);
          }
          else if (form == 'date') {
            var thisone = moment(answer['stamp']).format('L')
            self.$el.find("#"+q_id).find('input').val(thisone);
          }
          else if (form == 'datetime') {
            var this_moment = moment(answer['stamp']);
            var real_moment = moment(this_moment._a);
            //refactor model.want to show survey's TZ
            var this_answer = real_moment.format('L LT') + ' ' + window.tz_abbr;
            var thisone = this_answer;
            self.$el.find("#"+q_id).find('input').val(thisone);
          }
          else if (_.include(['geo_point','geo_polygon','geo_line','geo_circle'],form)) {
            var thesepoints = answer['points'];
            if (form == 'geo_point') {
              var entity = new L.Marker([thesepoints[0].lat,thesepoints[0].lng],{icon:window.green_icon});
            }
            else if (form == 'geo_polygon') {
              var entity = new L.Polygon(thesepoints);
            }
            else if (form == 'geo_line') {
              var entity = new L.Polyline(thesepoints);
            }
            var center = (form == 'geo_point') ? entity.getLatLng() : thisCentroid(entity);
            model.set({'entity':entity})
            this.map.addLayer(entity);
            this.map.panTo(center)
          }
      }

    },

    entryLoad: function(entry) {
      var theseanswers = entry.get('answers');
      var self = this;
      this.$el.find("#respondent_id").val(entry.get('uid'));
      this.drawInProgress = false;

      var map_question = undefined;
      _.each(theseanswers, function (answer) {
        var mid = answer['question_id'];
        var question = self.options.questions.findWhere({'id':mid});
        question.set({'answer':answer }); //set according to this entry;

        if (!map_question && (question.get('form') === map_form)) {
          map_question = question; //define map q if not done yet
        }
      });

      var possible_entity = map_question.get('entity');
      if (possible_entity) {
        entry.trigger('loadedFinishedEntry', possible_entity);
      }
      else {
        entry.trigger('loadedUnfinishedEntry');
      }

      this.$el.find('.leaflet-control-pointsetter').hide('fast');
    },

    loadedUnfinished: function() {
      //For entry with no geodata yet.
      this.$el.find("#location_data").empty();
      this.$el.find(".leaflet-control-draw, #instructions").show();
    },

    loadedFinished: function(entity) {
      //For entry with geodata yet.
      this.$el.find(".leaflet-control-draw").hide('fast') //if its visible..get rid of the draw.Since this entry is already done.
      this.$el.find("#instructions").hide();
      this.handleGeoData(entity);
    },

    handleGeoData: function(entity) {
      var points = (map_form == 'geo_point') ? [entity._latlng] : entity._latlngs;
      var stuff = _.template($("#loc_template").html(), { points: points });
      this.$el.find("#location_data").html(stuff).show();
    },

    selectorChange: function(e) {
      if (this.drawInProgress) {
        this.showWarning(e,$('.leaflet-control-pointsetter'));
        this.$el.find('select').select2('val',this.lastIdGrabbed); //Force a switch back to previous value.
      }
      else {
        this.loadResult(e.val); //Load this requested answer set
      }
    },

    updateProgressBar: function(e) {
      var newCount = parseInt(this.$el.find("#completed_count").text());
      var newPercent = ((newCount/full_count)*100)+"%";
      this.$el.find('.bar').css('width',newPercent);
    },

    saveCurrent: function(e) {
      var self = this;
      var control = this.$el.find('.pointsetter-commit');
      control.text('Saving');
      var parentControl = this.$el.find('.leaflet-control-pointsetter');
      parentControl.popover('hide');
      this.updateUploadedEntry(function() {
        parentControl.hide('fast');
        self.$el.find("#ready, #pending").hide();
        control.text(form_to_nameset[map_form].entity_name);
      });
      return false;
    },

    updateUploadedEntry: function (callback) {
      var selectorMain = this.$el.find('select');
      var self = this;
      //collect answers
      var thisentry = this.collection.get(self.lastIdGrabbed);
      
      var map_answer = _.find(thisentry.get('answers'), function (answer) {
        return (answer.question_id === self.map_question.get('id'))
      });

      var entity = self.map_question.get('entity');

      map_answer.points = (map_form === 'geo_point') ? [entity.getLatLng()] : entity.getLatLngs();
      
      var current_model = this.collection.get(self.lastIdGrabbed); //grab fresh copy of entry.
      current_model.save({}, {
        success:function (e) {
          self.drawInProgress = false;
          self.handleGeoData(entity);
          self.$el.find("#completed_count").text(parseInt(self.$el.find("#completed_count").text())+1);
          self.updateProgressBar();

          //finish
          var id = current_model.id;
          var current_option_element = self.$el.find('option[value="'+id+'"]'); //find current element in select2
          var newInnerHtml = current_option_element.html().replace('remove','ok'); //change FA icon class.
          current_option_element.html(newInnerHtml);//Change existing in old select
          selectorMain.select2('val',id); //Update selected in view;


          if (_.include(['geo_polygon','geo_line'], map_form)) {
            entity.editing.disable();
            entity.setStyle(sorted_path);
          }
          else {
            entity.setIcon(window.green_icon);
          }

          entity.dragging.disable();

          if (typeof callback === 'function') {
            callback();
          }
        },
        error: function (e) {
          alert('There was an error updating this entry.')
        }
      });
      
    },

    leaveEdit:  function(e) {
      var self = this;
      if (this.drawInProgress) {
        this.showWarning(e,self.$el.find('.leaflet-control-pointsetter'));
      }
      else {
        window.location = "<%= url_for survey_analyze_path(@report.survey) %>";
      }
      return false;
    },

    loadResult: function (id) {
    //Clean existing question data.
      var self = this;
      this.options.questions.each(function(question) {
        question.set({'answer':null});
        if (_.include(['geo_point','geo_circle','geo_polygon','geo_line'], question.get('form'))) {
          var entity = question.get('entity');
          if (entity) {
            self.map.removeLayer(entity); //remove current entity from map.
            question.set({'entity':null});
          }
        }
      });

      var test_grab = Spresults.get(id);
      var self = this;
      if (test_grab) {
        test_grab.launchOn();
      }
      else {
        //TODO: Use this model?
        var result = new Spresult();
        result.id = id;
        result.fetch({
          success: function (model, response) {
            self.collection.add(model, {silent: true});
            model.launchOn();
          }
        });
      }
      this.lastIdGrabbed = id;
    }
  });


  $(document).ready(function() {
    var thisEditSection = new UploadedEditSection({
      collection: Spresults,
      model: Spresult,
      method: 'uploaded',
      questions: questions
    });
  });

</script>
